# coding=utf-8
# Copyright 2022-present, the HuggingFace Inc. team.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Contains a tool to add/check the definition of "async" methods of `HfApi` in `huggingface_hub.hf_api.py`."""
import argparse
import inspect
import os
import re
import tempfile
from pathlib import Path
from typing import NoReturn

import black
from ruff.__main__ import find_ruff_bin

from huggingface_hub.hf_api import _HfApi


TEMPLATE_START = '''
# coding=utf-8
# Copyright 2022-present, the HuggingFace Inc. team.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""
WARNING: this file is automatically generated by `utils/check_threaded_hf_api.py`. Do not edit it manually.
You can check it is up-to-date by running `make quality` and update its content with `make style` if needed.

The content of this file is mostly based on HfApi implementation.
"""
from __future__ import annotations

from concurrent.futures import Future, ThreadPoolExecutor
from typing import Dict, Optional, Union

from .hf_api import *  # noqa: F403
from .hf_api import _HfApi


class _ThreadedHfApi(_HfApi):
    _thread_pool: Optional[ThreadPoolExecutor] = None

    @property
    def thread_pool(self) -> ThreadPoolExecutor:
        # Calls to the Hub can be run in the background. Tasks are queued to preserve order but do not block the main
        # thread. Can be useful to upload data during a training. ThreadPoolExecutor is initialized the first time it's
        # used. Non-blocking methods are suffixed by `_threaded`.
        if self._thread_pool is None:
            self._thread_pool = ThreadPoolExecutor(max_workers=1)
        return self._thread_pool

'''

TEMPLATE_DOCSTRING = """
        This is a non-blocking method. Check out [`{method_name}`] documentation to learn how to use it. The threaded version
        starts a background job in a separate thread and returns a Future object. The goal of background jobs is to
        avoid blocking the main thread for example in a training. You should not expect a gain in performances by
        parallelizing tasks with multiple threads as we favored a solution where jobs are run sequentially to preserve
        order. If you need more flexibility, you can have a look to the [ThreadPoolExecutor](https://docs.python.org/3/library/concurrent.futures.html#threadpoolexecutor)
        documentation."""

INDENT = " " * 8

HF_API_FILE_PATH = Path(__file__).parents[1] / "src" / "huggingface_hub" / "hf_api.py"
HF_API_FILE_CONTENT = HF_API_FILE_PATH.read_text()

THREADED_HF_API_FILE_PATH = Path(__file__).parents[1] / "src" / "huggingface_hub" / "_threaded_hf_api.py"


def generate_threaded_method(method_name: str) -> str:
    """Generate code to define a threaded version of a method of HfApi."""
    group = re.search(rf'(def {method_name}\(.*?)"""(.*?)"""', HF_API_FILE_CONTENT, re.DOTALL)
    assert group is not None

    # signature
    signature = group.group(1).strip()
    signature = signature.replace(method_name, f"{method_name}_threaded", 1)
    signature = re.sub(r"-> (.*)?:", r"-> Future[\1]:", signature)
    signature = f"\n    {signature}"

    # docstring
    for line in group.group(2).strip().splitlines():
        if line.strip():
            line = line.strip()
            break
    else:
        raise ValueError(f"No docstring found for {method_name}.")
    docstring = f'{INDENT}"""\n{INDENT}{line}\n{TEMPLATE_DOCSTRING.format(method_name=method_name)}\n{INDENT}"""'

    # code
    submit_args = ""
    for parameter in inspect.signature(getattr(_HfApi, method_name)).parameters.values():
        if parameter.name == "self":
            continue
        elif parameter.kind == parameter.POSITIONAL_ONLY or parameter.kind == parameter.POSITIONAL_OR_KEYWORD:
            submit_args += f"{parameter.name},"
        elif parameter.kind == parameter.VAR_POSITIONAL:
            submit_args += f"*{parameter.name},"
        elif parameter.kind == parameter.KEYWORD_ONLY:
            submit_args += f"{parameter.name}={parameter.name},"
        elif parameter.kind == parameter.VAR_KEYWORD:
            submit_args += f"**{parameter.name},"
        else:
            raise ValueError(f"Unknown Parameter kind: {parameter}")
    submit_line = f"{INDENT}return self.thread_pool.submit(self.{method_name}, {submit_args.strip(',')})"

    return signature + "\n" + docstring + "\n" + submit_line + "\n"


def generate_threaded_hf_api() -> str:
    raw_code = TEMPLATE_START
    for method_name, _ in inspect.getmembers(_HfApi, predicate=inspect.isfunction):
        if method_name.startswith("_"):  # skip private methods
            continue
        raw_code += generate_threaded_method(method_name)
    return format_generated_code(raw_code)


def format_generated_code(code: str) -> str:
    """
    Format some code with black+ruff. Cannot be done "on the fly" so we first save the code in a temporary file.
    """
    # Format with black
    code = black.format_file_contents(code, fast=False, mode=black.FileMode(line_length=119))

    # Format with ruff
    with tempfile.TemporaryDirectory() as tmpdir:
        filepath = Path(tmpdir) / "__init__.py"
        filepath.write_text(code)
        ruff_bin = find_ruff_bin()
        os.spawnv(os.P_WAIT, ruff_bin, ["ruff", str(filepath), "--fix", "--quiet", "--ignore=F405"])
        return filepath.read_text()


def check_threaded_hf_api(update: bool) -> NoReturn:
    """Check that the code defining the threaded version of HfApi is up-to-date."""
    # If expected `__init__.py` content is different, test fails. If '--update-init-file'
    # is used, `__init__.py` file is updated before the test fails.
    content = THREADED_HF_API_FILE_PATH.read_text()
    expected_content = generate_threaded_hf_api()
    if content != expected_content:
        if update:
            with THREADED_HF_API_FILE_PATH.open("w") as f:
                f.write(expected_content)

            print(
                "✅ _ThreadedHfApi implementation has been updated in `./src/huggingface_hub/_threaded_hf_api.py`."
                "\n   Please make sure the changes are accurate and commit them."
            )
            exit(0)
        else:
            print(
                "❌ Expected content mismatch in `./src/huggingface_hub/_threaded_hf_api.py`.\n   It is most likely"
                " that you modified `./src/huggingface_hub/hf_api.py`.\n   Please run `make style` or `python"
                " utils/check_threaded_hf_api.py --update`."
            )
            exit(1)

    print("✅ All good! (threaded HfApi)")
    exit(0)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--update",
        action="store_true",
        help="Whether to override `./src/huggingface_hub/_threaded_hf_api.py` if a change is detected.",
    )
    args = parser.parse_args()

    check_threaded_hf_api(update=args.update)

print(generate_threaded_hf_api())
# import pdb

# pdb.set_trace()
